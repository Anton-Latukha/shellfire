readonly core_libraryName=shellfire

core_message()
{
	local messageKind="$1"
	local message="$2"
	
	local shouldEcho
	case "$messageKind" in
	
		FAIL)
			shouldEcho=1
		;;
		
		WARN)
			shouldEcho=1
		;;
	
		INFO)
			if [ $core_init_verbosity -gt 0 ]; then
				shouldEcho=1
			fi
		;;
	
		DEBUG)
			if [ $core_init_verbosity -gt 1 ]; then
				shouldEcho=1
			fi
		;;
		
		TODO)
			shouldEcho=1
		;;
	
		*)
			shouldEcho=1
		;;

	esac
	
	if [ $shouldEcho -eq 1 ]; then
		printf '%s\n' "$global_ourName: $messageKind: $message" 1>&2
	fi
}

core_exitError()
{
	core_message FAIL "$1"
	exit 1
}

core_TODO()
{
	core_message TODO "$*"
}

_core_usesAlreadySourced=''
core_uses()
{
	local namespacedModules
	local alreadySourcedNamespacedFunctions
	local moduleName
	local relativeFunctionsFileName
	local functionsFilePath
	local sourced
	for namespacedModule in "$@"
	do
		# skip if already sourced
		# Does not handle spaces in filenames, unfortunately
		for alreadySourcedNamespacedFunction in $_core_usesAlreadySourced
		do
			if [ "$namespacedModule" = "$alreadySourcedNamespacedFunction" ]; then
				continue 2
			fi
		done
		
		_core_usesAlreadySourced="$_core_usesAlreadySourced $namespacedModule"
		moduleName="$(core_compatibility_basename "$namespacedModule")"
		sourced=0
		for relativeFunctionsFilePath in "$namespacedModule"."$global_preferredShell" "$namespacedModule" "$namespacedModule"/"$moduleName"."$global_preferredShell" "$namespacedModule"/"$moduleName"
		do
			functionsFilePath="$core_init_functionsPath"/"$core_libraryName"/"$relativeFunctionsFilePath".functions
			if [ -f "$functionsFilePath" ]; then
				. "$functionsFilePath" || core_exitError "Can not load functions '$functionsFilePath'"
				sourced=1
			fi
		done
		if [ $sourced -eq 0 ]; then
			core_exitError "Can not load functions for namespace '$namespacedModule'"
		fi
	done
}