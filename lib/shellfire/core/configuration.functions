# Consider breaking this out
core_configuration_ifPathIsExtantCallCallback()
{
	local checkConfigurationSecurity=$1
	local callback="$2"
	if [ $# -eq 3 ]; then
		local path="$3"
	else
		local environmentVariable="$3"
		local relativePath="$4"
		
		local blacklistedEnvironmentVariable
		for blacklistedEnvironmentVariable in $core_configuration_defaultsBlacklistedEnvironmentVariables
		do
			if [ "$blacklistedEnvironmentVariable" = "$environmentVariablePrefixingPath" ]; then
				return 0
			fi
		done
	
		if core_compatibility_testVariableIsUnset "$environmentVariable"; then
			return 0
		fi
		local parentPath="$(core_compatibility_indirectVariableValue "$environmentVariable")"
		if [ -z "$parentPath" ]; then
			return 0
		fi
		local path="${parentPath}${relativePath}"
	fi

	if [ -e "$path" ]; then
		if [ -r "$path" ]; then
			$callback "$path"
		fi
	fi
}

core_configuration_callbackLoadFile()
{
	local filePath="$1"
	if [ -f "$filePath" ]; then
		if [ -x "$filePath" ]; then
			core_message WARN "File '$filePath' is executable and should not be; ignoring"
			return 0
		fi
		. "$filePath" || core_exitError "Could not load '$filePath'"
	fi
}

core_configuration_callbackLoadFolder()
{
	local folderPath="$1"
	if [ -d "$folderPath" ]; then
		if [ -x "$folderPath" ]; then
			local filePath
			for filePath in "$folderPath"/*
			do
				core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile "$filePath"
			done
		fi
	fi
}

core_configuration_defaultsBlacklistedEnvironmentVariables=''
core_configuration_load()
{	
	core_TODO Security checks to be done for any "${core_init_configurationPath}" / '/etc' files
	# * They are not owned by root.
	# * They are not group writable.
	# * They are not world writable.
	# * They do not reside in a group writable directory.
	# * They do not reside in a world writable directory.
	# * They are not a symbolic link to a file residing in a group or world writable directory. 
	# Some of these needs can be accompolished by parsing  ls -a -l -L -n "$folderPath" | while IFS=' ' read -r permissions uid gid size month day file
	# Other might be best done by feature-checking stat (look at the lines of output)
	
	core_TODO Need to make sure we do not load config files more than once
	# This is problematic if they contain spaces - could we use an eval?
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile "${core_init_configurationPath}"/"${core_libraryName}"rc
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder "${core_init_configurationPath}"/"${core_libraryName}"rc.d
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile "${core_init_configurationPath}"/"${global_ourName}"rc
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder "${core_init_configurationPath}"/"${global_ourName}"rc.d
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile HOME /."${core_libraryName}"rc
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder HOME /."${core_libraryName}"rc.d
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile ${core_libraryName}_RC ''
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder ${core_libraryName}_RC_D ''
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile HOME /."${global_ourName}"rc
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder HOME /."${global_ourName}"rc.d
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile ${global_ourName}_RC ''
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder ${global_ourName}_RC_D ''
}

core_usesIn core compatibility
core_configuration_defaults()
{
	# Option 1: We are in /bin [or sbin]
	# * core_init_configurationPath=/etc
	# * core_init_functionsPath=/lib
	
	# Option 2: We are in /usr/bin [or sbin]
	# * core_init_configurationPath=/etc [unless /usr/etc exists]
	# * core_init_functionsPath=/usr/lib
	
	# Option 3: We are in /usr/local/bin [or sbin]
	# * core_init_configurationPath=/usr/local/etc
	# * core_init_functionsPath=/usr/local/lib
	
	# Option 4: We are in /opt/package[-version]/bin or some subfolder
	# * resolve relative to location, ie go up one and down one
	# * this also works for installs in $HOME [see 5 below], and for Option 8, as long as we realise there's no /usr/etc
	
	# Option 5: We are in $HOME/bin [sbin]
	# * core_init_configurationPath=/etc
	# * core_init_functionsPath=/lib
	
	# Option 7: We are in $HOME/usr/bin [sbin]
	# * core_init_configurationPath=/etc
	# * core_init_functionsPath=/usr/lib
	
	# Option 8: We are in a debian package layout
	# check if we're in a xxx/bin, a xxx/usr/bin, a xxx/usr/local/bin, a xx/opt, then apply rules for Options 1 - 4
	
	# Option 9: We are in a git repository
	# * detect the presence of .git by going up parent folders - we'll either hit the root or a submodule
	# * hmmmm
	
	# Option 9a: we are the main bash script in a repository - we expect to have our functions file parallel to us, and shellfire modules in lib/shellfire
	# Option 9b: we are not, eg in the case of a build script for java2c.
	
	# A more sophisticated scheme would use locale -a and hunt for an UTF-8 locale, but language needs to be stable over multiple invocations if data is persistent
	# Can also be 'en_GB.UTF-8' or 'C' (but that's not unicode aware) or ?C.UTF-8?
	core_compatibility_setVariableIfUnset core_init_language 'en_US.UTF-8'
	core_compatibility_setVariableIfUnset core_init_verbosity 0
}
