# Consider breaking this out
core_configuration_ifPathIsExtantCallCallback()
{
	local checkConfigurationSecurity=$1
	local callback="$2"
	if [ $# -eq 3 ]; then
		local path="$3"
	else
		local environmentVariable="$3"
		local relativePath="$4"
		
		local blacklistedEnvironmentVariable
		for blacklistedEnvironmentVariable in $core_configuration_defaultsBlacklistedEnvironmentVariables
		do
			if [ "$blacklistedEnvironmentVariable" = "$environmentVariablePrefixingPath" ]; then
				return 0
			fi
		done
	
		if core_compatibility_testVariableIsUnset "$environmentVariable"; then
			return 0
		fi
		local parentPath="$(core_compatibility_indirectVariableValue "$environmentVariable")"
		if [ -z "$parentPath" ]; then
			return 0
		fi
		local path="${parentPath}${relativePath}"
	fi

	if [ -e "$path" ]; then
		if [ -r "$path" ]; then
			$callback "$path"
		fi
	fi
}

core_configuration_callbackLoadFile()
{
	local filePath="$1"
	if [ -f "$filePath" ]; then
		if [ -x "$filePath" ]; then
			core_message WARN "File '$filePath' is executable and should not be; ignoring"
			return 0
		fi
		. "$filePath" || core_exitError "Could not load '$filePath'"
	fi
}

core_configuration_callbackLoadFolder()
{
	local folderPath="$1"
	if [ -d "$folderPath" ]; then
		if [ -x "$folderPath" ]; then
			local filePath
			for filePath in "$folderPath"/*
			do
				core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile "$filePath"
			done
		fi
	fi
}

core_configuration_defaultsBlacklistedEnvironmentVariables=''
core_configuration_load()
{	
	core_TODO Security checks to be done for any '/etc' files
	# * They are not owned by root.
	# * They are not group writable.
	# * They are not world writable.
	# * They do not reside in a group writable directory.
	# * They do not reside in a world writable directory.
	# * They are not a symbolic link to a file residing in a group or world writable directory. 
	# Some of these needs can be accompolished by parsing  ls -a -l -L -n "$folderPath" | while IFS=' ' read -r permissions uid gid size month day file
	# Other might be best done by feature-checking stat (look at the lines of output)
	
	core_TODO Need to make sure we dont load config files more than once
	# This is problematic if they contain spaces - could we use an eval?
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile "${core_init_rootPath}"/etc/"${core_libraryName}"rc
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder "${core_init_rootPath}"/etc/"${core_libraryName}"rc.d
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile "${core_init_rootPath}"/etc/"${global_ourName}"rc
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder "${core_init_rootPath}"/etc/"${global_ourName}"rc.d
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile HOME /."${core_libraryName}"rc
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder HOME /."${core_libraryName}"rc.d
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile ${core_libraryName}_RC ''
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder ${core_libraryName}_RC_D ''
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile HOME /."${global_ourName}"rc
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder HOME /."${global_ourName}"rc.d
	
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFile ${global_ourName}_RC ''
	core_configuration_ifPathIsExtantCallCallback core_configuration_callbackLoadFolder ${global_ourName}_RC_D ''
}

core_usesIn core compatibility
core_configuration_defaults()
{
	# /opt/<package-name>, /bin, /usr/bin, /usr/local/bin, $HOME/bin installation locations? /sbin et al, too?
	
	# A more sophisticated scheme would use locale -a and hunt for an UTF-8 locale, but language needs to be stable over multiple invocations if data is persistent
	# Can also be 'en_GB.UTF-8' or 'C' (but that's not unicode aware)
	core_compatibility_setVariableIfUnset core_init_language 'en_US.UTF-8'
	core_compatibility_setVariableIfUnset core_init_verbosity 0
}
