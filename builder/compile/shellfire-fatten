#!/usr/bin/env sh

# TODO: core_uses and core_functions_register are 'special' functions that a simple sourcing compiler writes stubs for

# goal is to create three forms of executable
# * one that is completely standalone, including paths files [but can still make use of overrides]
# * one that is completely standalone, excluding paths files and with functions in /lib
#   * possible variant that shares functions? ?why? creates unnecesary version tensions, requires ABI compat, etc - a bit like shared libraries today
#   * if not the above, then core_init_functionsPath
# * one that can run from checkout of git & git submodules

# paths files are composable
# * work simply by combining those defined in shellfire with local choices
# * allow local, git friendly, replacements OR additions

#compile_deduceRepositoryFolderPath()
#{
#	if [ "${TRAVIS_BUILD_DIR+set}" = 'set' ]; then
#		readonly compile_repositoryFolderPath="$TRAVIS_BUILD_DIR"
#	else
#		readonly compile_repositoryFolderPath="$(pwd)"
#	fi
#	# TRAVIS_COMMIT='ab8186e73e9676d2c547f07b309499ebeed27ec0'
#}

compile_sourceInitFunctions()
{
	local libraryFunctionsFolderPath="$core_init_functionsPath"/shellfire
	if [ ! -d "$libraryFunctionsFolderPath" ]; then
		printf '%s\n' "Can not find '$libraryFunctionsFolderPath' - did you run this script from the root of the repository?"
	fi
	_compile_sourceInitFunctionsRecursively "$libraryFunctionsFolderPath"
}

 --target "$project" --clean-first --use-stderr -- --jobs "$cpucount_makeJobs" --load-average "$cpucount_makeLoadAverage"
	done
}

_program()
{
	echo "hello"
}

readonly _program_name='shellfire-fatten'
readonly _program_version='unversioned'
readonly _program_package_or_build=''
readonly _program_copyright='(C) 2014 Raphael Cohn'
readonly _program_licence='MIT'
readonly _program_written_by='Raphael Cohn'
readonly _program_path="$([ "${0%/*}" = "${0}" ] && printf '%s\n' '.' || printf '%s\n' "${0%/*}")"
readonly _program_lib_path="${_program_path}/../../lib"
readonly _program_etc_path="${_program_path}/../../etc"
readonly _program_uses='compile'

_program_commandLine_parseInitialise()
{
	# Needed in help text
	_program_default_etc_path='/etc'
	_program_default_lib_path='/usr/lib'
}

_program_commandLine_helpMessage()
{
	_program_commandLine_helpMessage_usage="[OPTION]... -- [PROGRAMS]..."
	_program_commandLine_helpMessage_description="Builds projects using CMake."
	_program_commandLine_helpMessage_options="
-r, --repository-path PATH  Path to folder containing a PROGRAM
-e, --etc-path PATH  Path to install fir etc folder [Default ${_program_default_etc_path}]
-l, --lib-path PATH  Path to lib folder [Default ${_program_default_lib_path}]
"
	_program_commandLine_helpMessage_configurationKeys=$'\n'
	_program_commandLine_helpMessage_examples="
  ${global_ourName} -r git-repo/bin -- cmake-scripted
"
}

_program_commandLine_optionExists()
{
	case "$optionName" in
		
		r|repository-path)
			echo 'yes-argumented'
		;;
		
		e|etc-path)
			echo 'yes-argumented'
		;;
		
		l|lib-path)
			echo 'yes-argumented'
		;;
		
		*)
			echo 'no'
		;;
		
	esac
}

_program_commandLine_processOptionWithoutArgument()
{
	# optionName
	:
}

_program_commandLine_processOptionWithArgument()
{
	case "$optionName" in
		
		r|repository-path)
			core_validate_folderPathReadableAndSearchable 'option' "$optionNameIncludingHyphens" "$optionValue"
			shellfire_fatten_repository_path="$optionValue"
		;;
		
		e|etc-path)
			core_validate_pathNotEmpty 'option' "$optionNameIncludingHyphens" "$optionValue"
			shellfire_fatten_etc_path="$optionValue"
		;;
		
		l|lib-path)
			core_validate_pathNotEmpty 'option' "$optionNameIncludingHyphens" "$optionValue"
			shellfire_fatten_lib_path="$optionValue"
		;;
		
		*)
			echo 'no'
		;;
		
	esac
	
	# optionName optionValue
	:
}

_program_commandLine_handleNonOptions()
{
	if [ $# -eq 0 ]; then
		core_exitError "No programs specified"
	fi
	
	# TODO: Not sh friendly, and objects violently if dash as a syntax error!
	# Problem is we want to preserve in an array if using bash 3...
	# bash 3 does support array initialisers
	
	xxxx: initialise varargs
	#cmake_scripted_projects=("$@")
}

_program_commandLine_validate()
{
	local optionNameIncludingHyphens
	local optionValue
	
	if core_compatibility_testVariableIsUnset shellfire_fatten_repository_path; then
		core_exitError "The option '${optionNameIncludingHyphens}' must be specified"
	else
		core_validate_folderPathReadableAndSearchable 'configuration setting' 'shellfire_fatten_repository-path' "$shellfire_fatten_repository_path"
	fi
	
	if core_compatibility_testVariableIsUnset shellfire_fatten_etc_path
		shellfire_fatten_etc_path="$_program_default_etc_path"
	else
		core_validate_pathNotEmpty 'configuration setting' 'shellfire_fatten_etc_path' "$shellfire_fatten_etc_path"
	fi
	
	if core_compatibility_testVariableIsUnset shellfire_fatten_lib_path
		shellfire_fatten_etc_path="$_program_default_lib_path"
	else
		core_validate_pathNotEmpty 'configuration setting' 'shellfire_fatten_lib_path' "$shellfire_fatten_lib_path"
	fi
}

# Assumes pwd, and so requires this code to be running from this folder
. "$_program_lib_path"/shellfire/core/init.functions "$@"





# add a shebang line
# copy all .init-functions files into a file
# set the variable  core_init_functionsPath
# if not compiling:-
#  * add a core_init_functionsPath=XXXX definition [perhaps as $(core_init_computeFunctionsPath)]
#  * add a core_init_main "$@"
#  * repeat for sh, dash, bash
# else:-
#  * create special  cores_uses  and  core_functions_register  functions
#  * explicitly call  core_uses core
#  *  source program code
#  * add a core_init_functionsPath=XXXX definition
#  * add a core_init_main "$@"

# we assemble this file, effectively, and so should include a revision_blob or somesuch so we can tell if we're out-of-date
# if it ends .init-functions, it goes in here. Order only matters for the final line  init_main "$@"  but we could generate that
# if we're standing alone, then we need to set core_
# if we're including all functions, then we need to override core_uses

# 0 create empty file somewhere
# 1 set the 
# 2 find all .init-functions, and output to new file
# 3 (optional) output all other functions by overridding core_use

