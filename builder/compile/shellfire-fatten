#!/usr/bin/env bash

# TODO: core_uses and core_functions_register are 'special' functions that a simple sourcing compiler writes stubs for

# goal is to create three forms of executable
# * one that is completely standalone, including paths files [but can still make use of overrides]
# * one that is completely standalone, excluding paths files and with functions in /lib
#   * possible variant that shares functions? ?why? creates unnecesary version tensions, requires ABI compat, etc - a bit like shared libraries today
#   * if not the above, then core_init_functionsPath
# * one that can run from checkout of git & git submodules

# paths files are composable
# * work simply by combining those defined in shellfire with local choices
# * allow local, git friendly, replacements OR additions

#compile_deduceRepositoryFolderPath()
#{
#	if [ "${TRAVIS_BUILD_DIR+set}" = 'set' ]; then
#		readonly compile_repositoryFolderPath="$TRAVIS_BUILD_DIR"
#	else
#		readonly compile_repositoryFolderPath="$(pwd)"
#	fi
#	# TRAVIS_COMMIT='ab8186e73e9676d2c547f07b309499ebeed27ec0'
#}

# add a shebang line
# copy all .init-functions files into a file
# set the variable  core_init_functionsPath
# if not compiling:-
#  * add a core_init_functionsPath=XXXX definition [perhaps as $(core_init_computeFunctionsPath)]
#  * add a core_init_main "$@"
#  * repeat for sh, dash, bash
# else:-
#  * create special  cores_uses  and  core_functions_register  functions
#  * explicitly call  core_uses core
#  *  source program code
#  * add a core_init_functionsPath=XXXX definition
#  * add a core_init_main "$@"

# we assemble this file, effectively, and so should include a revision_blob or somesuch so we can tell if we're out-of-date
# if it ends .init-functions, it goes in here. Order only matters for the final line  init_main "$@"  but we could generate that
# if we're standing alone, then we need to set core_
# if we're including all functions, then we need to override core_uses

# 0 create empty file somewhere
# 1 set the 
# 2 find all .init-functions, and output to new file
# 3 (optional) output all other functions by overridding core_use

_program()
{
	core_usesIn core/variable array
	
	core_dependency_requires '*' sed
	_shellfire_fatten_replaceProgramReadonlyValue()
	{
		local name="$1"
		local value="$2"
		sed -e 's,^readonly '"${name}"'=.*$,readonly '"${name}"'='"'${value}'"',g'
	}
	
	_shellfire_fatten_removeInitFunctionsSourcing()
	{
		sed -e 's,^. "$_program_libPath"/shellfire/core/init.functions "$@".*,,g'
	}
	
	shellfire_fatten_createTemporaryFolder()
	{
		local TMP_FOLDER
		core_temporaryFiles_newFolderToRemoveOnExit
		shellfire_fatten_outputFolderPath="$TMP_FOLDER"
	}
	
	# We're supposed to use git's "low-level plumbing" and avoid 'porcelain' commands. Given how hideous git's syntax is, life is too short. We'll fix the bugs that arise instead.
	core_dependency_requires '*' git date awk sort md5sum
	shellfire_fatten_obtainGitDetails()
	{
		pushd "$shellfire_fatten_repositoryPath"
		
			if [ ! -d '.git' ]; then
				core_exitError "--repository-path '$shellfire_fatten_repositoryPath' is not a git repository"
			fi
			
			shellfire_fatten_branch="$(git branch | awk '/^\*/ {print $2}')"
			shellfire_fatten_commit="$(git log -n 1 --format='%H')"
			shellfire_fatten_authors="$(git log --format='%aN' | sort -u | awk 'NR==1 {ORS=""; print $0}; NR>1 {ORS=""; print ", " $0}')"
			local iso8601Date="$(git log -n 1 --format='%ci')"
			shellfire_fatten_version="$(date -d "$iso8601Date" '+%Y.%m.%d.%H.%M')"
			shellfire_fatten_programPath=''
			
			if [ "$shellfire_fatten_force" = 'no' ]; then
				local pendingChanges="$(git diff --minimal --no-color --name-status)"
				if [ -n "$pendingChanges" ]; then
					core_exitError $core_commandLine_exitCode_DATAERR "Pending changes in --repository-path '$shellfire_fatten_repositoryPath'"
				fi
				shellfire_fatten_packageOrBuild="$shellfire_fatten_branch $shellfire_fatten_commit $(git diff --minimal --no-color | md5sum | awk '{print $1}')"
			else
				shellfire_fatten_packageOrBuild="$shellfire_fatten_branch $shellfire_fatten_commit "
			fi
			
		popd
	}

	core_dependency_requires '*' env bash chmod head cat
	shellfire_fatten_fattenProgram()
	{
		local shellfire_fatten_originalProgram="$core_variable_array_element"
		local shellfire_fatten_programPath="$(core_compatibility_dirname "$shellfire_fatten_originalProgram")"
		local shellfire_fatten_programName="$(core_compatibility_basename "$shellfire_fatten_originalProgram")"
		local shellfire_fatten_fattenedProgram="$shellfire_fatten_outputFolderPath"/"$shellfire_fatten_programName"
		local shellfire_fatten_temporaryProgram="$shellfire_fatten_fattenedProgram".tmp
		local shellfire_fatten_bootstrapProgram="$shellfire_fatten_fattenedProgram"
		
		local shellfire_fatten_branch
		local shellfire_fatten_commit
		local shellfire_fatten_authors
		local shellfire_fatten_version
		local shellfire_fatten_programPath
		shellfire_fatten_obtainGitDetails
		
		_shellfire_fatten_fattenProgramCallback()
		{
			if [ ! -s "$filePath" ]; then
				return 0
			fi
			local lengthOf=".functions"
			shellfire_fatten_allPackageManagers="$shellfire_fatten_allPackageManagers $(core_variable_allButLastN "$(core_compatibility_basename "$filePath")" ${#lengthOf})"
		}
		
		local shellfire_fatten_allPackageManagers=""
		core_path_iterateOverFolderPath "$_program_libPath"/"$core_libraryName"/core/dependency/check _shellfire_fatten_fattenProgramCallback
		
		cat >>"$shellfire_fatten_bootstrapProgram" <<-EOF
			$(head -n 1 "$shellfire_fatten_originalProgram")
			set -e
			set -u
			_program_fattening_shebang='$(head -n 1 "$shellfire_fatten_originalProgram")'
			_program_fattening_path='$(core_compatibility_dirname "$shellfire_fatten_originalProgram")'
			_program_fattening_file='$shellfire_fatten_originalProgram'
			_program_fattening_allPackageManagers="$shellfire_fatten_allPackageManagers"
		EOF
		cat >>"$shellfire_fatten_bootstrapProgram" <<-'EOF'
			core_init_shell_rexecing=$$
			readonly _program_fattening=1
			_program_fattening_declaredNames=''
			
			cd "$_program_fattening_path" 1>/dev/null
			. "$_program_fattening_file"
			
			# Get rid of the original definitions
			core_dependency_declares()
			{
				:
			}
			_program()
			{
				:
			}
			
			# Shebang
			printf '%s\n' "$_program_fattening_shebang"
			
			# Global Variables
			IFS=' '
			set -o noglob
			for _program_fattening_declaredName in $_program_fattening_declaredNames
			do
				declare -p "$_program_fattening_declaredName"
			done
			
			# Dependencies
			while IFS="$core_variable_array_delimiter" read -r packageManager programName
			do
				if [ -z "$packageManager" ]; then
					break
				fi
				
				if [ "$packageManager" = '*' ]; then
					packageManagers="$_program_fattening_allPackageManagers"
				else
					packageManagers="$packageManager"
				fi
				
				IFS=' '
				for packageManager in $packageManagers
				do	
					for externalDataSourceFolderName in "$_program_name" "$core_libraryName"
					do
						externalDataSourceFilePath="$_program_etcPath"/"$externalDataSourceFolderName"/"$packageManager"/"$programName".path
						if core_path_isReadableNonEmptyFilePath "$externalDataSourceFilePath"; then
							printf '%s' "declare -r _core_dependency_internalDataSource_${packageManager}_${programName}='"
							printf '%s' "$(head -n 1 "$externalDataSourceFilePath")
							printf '%s\n' "'"
							break
						fi
					done
				done
			done <<-EOG
				${_core_dependency_requires}
			EOG
			
			# Functions
			declare -f
			
			# Execute
			printf '%s\n' 'core_init_main "$@"'
		EOF
		bash "$shellfire_fatten_bootstrapProgram"
		
		
		
		exit 60
		
		cat "$shellfire_fatten_originalProgram" \
			| _shellfire_fatten_replaceProgramReadonlyValue _program_name "$shellfire_fatten_programName" \
			| _shellfire_fatten_replaceProgramReadonlyValue _program_version "$shellfire_fatten_version" \
			| _shellfire_fatten_replaceProgramReadonlyValue _program_package_or_build "$shellfire_fatten_packageOrBuild" \
			| _shellfire_fatten_replaceProgramReadonlyValue _program_path "$shellfire_fatten_programPath" \
			| _shellfire_fatten_replaceProgramReadonlyValue _program_libPath "$shellfire_fatten_libPath" \
			| _shellfire_fatten_replaceProgramReadonlyValue _program_etcPath "$shellfire_fatten_etcPath" \
			| _shellfire_fatten_removeInitFunctionsSourcing
	}

	shellfire_fatten()
	{
		local shellfire_fatten_outputFolderPath
		shellfire_fatten_createTemporaryFolder
		
		core_variable_array_iterate shellfire_fatten_programs shellfire_fatten_fattenProgram
	}
}

readonly _program_name='shellfire-fatten'
readonly _program_version='unversioned'
readonly _program_package_or_build=''
readonly _program_copyright='(C) 2014 Raphael Cohn'
readonly _program_licence='MIT'
readonly _program_written_by='Raphael Cohn'
readonly _program_path="$([ "${_program_fattening_path+set}" = 'set' ] && printf '%s\n' "$_program_fattening_path" || ([ "${0%/*}" = "${0}" ] && printf '%s\n' '.' || printf '%s\n' "${0%/*}"))"
readonly _program_libPath="${_program_path}/../../lib"
readonly _program_etcPath="${_program_path}/../../etc"
readonly _program_entrypoint='shellfire_fatten'

_program_commandLine_parseInitialise()
{
	# Needed in help text
	_program_default_etcPath='/etc'
	_program_default_libPath='/usr/lib'
}

_program_commandLine_helpMessage()
{
	_program_commandLine_helpMessage_usage="[OPTION]... -- [PROGRAMS]..."
	_program_commandLine_helpMessage_description="Builds projects using CMake."
	_program_commandLine_helpMessage_options="
  -r, --repository-path PATH  Path to folder containing a PROGRAM
  -e, --etc-path PATH         Path to install fir etc folder [Default ${_program_default_etcPath}]
  -l, --lib-path PATH         Path to lib folder [Default ${_program_default_libPath}]
  -f, --force                 Force fattening even if there are uncommited changes"
    _program_commandLine_helpMessage_optionsSpacing='     '
	_program_commandLine_helpMessage_configurationKeys="
  shellfire_fatten_etcPath  Equivalent to --etc-path
  shellfire_fatten_libPath  Equivalent to --lib-path
  shellfire_fatten_repositoryPath  Equivalent to --repository-path
  shellfire_fatten_force  Equivalent to --force (specify yes or no)
"
	_program_commandLine_helpMessage_examples="
  ${_program_name} -r git-repo/bin -- minor-test
"
}

_program_commandLine_optionExists()
{
	case "$optionName" in
		
		r|repository-path)
			echo 'yes-argumented'
		;;
		
		e|etc-path)
			echo 'yes-argumented'
		;;
		
		f|force)
			echo 'yes-argumentless'
		;;
		
		l|lib-path)
			echo 'yes-argumented'
		;;
		
		*)
			echo 'no'
		;;
		
	esac
}

_program_commandLine_processOptionWithoutArgument()
{
	case "$optionName" in
		
		f|force)
			shellfire_fatten_force='yes'
		;;
		
	esac
}

_program_commandLine_processOptionWithArgument()
{
	case "$optionName" in
		
		r|repository-path)
			core_validate_folderPathReadableAndSearchable $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue"
			shellfire_fatten_repositoryPath="$optionValue"
		;;
		
		e|etc-path)
			core_validate_pathNotEmpty $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue"
			shellfire_fatten_etcPath="$optionValue"
		;;
		
		l|lib-path)
			core_validate_pathNotEmpty $core_commandLine_exitCode_USAGE 'option' "$optionNameIncludingHyphens" "$optionValue"
			shellfire_fatten_libPath="$optionValue"
		;;
		
		*)
			echo 'no'
		;;
		
	esac
}

_program_commandLine_handleNonOptions()
{
	if [ $# -eq 0 ]; then
		core_exitError $core_commandLine_exitCode_USAGE "No programs specified"
	fi
	local shellfire_fatten_program
	for shellfire_fatten_program in "$@"
	do
		core_validate_filePathReadableAndExecutableAndNotEmpty $core_commandLine_exitCode_USAGE 'non-options' 'programs' "$shellfire_fatten_program"
		
		cd -P "$(core_compatibility_dirname "$shellfire_fatten_program")" 1>/dev/null
		
			shellfire_fatten_program="$(pwd)"/"$(core_compatibility_basename "$shellfire_fatten_program")"
		
		cd - >/dev/null
		
		core_variable_array_append shellfire_fatten_programs "$shellfire_fatten_program"
	done
}

_program_commandLine_validate()
{
	local optionNameIncludingHyphens
	local optionValue
	
	if core_variable_isUnset shellfire_fatten_force; then
		shellfire_fatten_force='no'
	else
		core_validate_yesOrNo $core_commandLine_exitCode_CONFIG 'configuration setting' 'shellfire_fatten_force' "$shellfire_fatten_force"
	fi
	
	if core_variable_isUnset shellfire_fatten_repositoryPath; then
		core_exitError $core_commandLine_exitCode_USAGE "The option '--repository-path (-r)' must be specified"
	else
		core_validate_folderPathReadableAndSearchable $core_commandLine_exitCode_CONFIG 'configuration setting' 'shellfire_fatten_repositoryPath' "$shellfire_fatten_repositoryPath"
	fi
	
	if core_variable_isUnset shellfire_fatten_etcPath; then
		shellfire_fatten_etcPath="$_program_default_etcPath"
	else
		core_validate_pathNotEmpty $core_commandLine_exitCode_CONFIG 'configuration setting' 'shellfire_fatten_etcPath' "$shellfire_fatten_etcPath"
	fi
	
	if core_variable_isUnset shellfire_fatten_libPath; then
		shellfire_fatten_libPath="$_program_default_libPath"
	else
		core_validate_pathNotEmpty $core_commandLine_exitCode_CONFIG 'configuration setting' 'shellfire_fatten_libPath' "$shellfire_fatten_libPath"
	fi
}

# Assumes pwd, and so requires this code to be running from this folder
. "$_program_libPath"/shellfire/core/init.functions "$@"
