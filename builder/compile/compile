#!/usr/bin/env sh
set -e
set -u

# TODO: core_uses and core_functions_register are 'special' functions that a simple sourcing compiler writes stubs for

# goal is to create three forms of executable
# * one that is completely standalone, including paths files [but can still make use of overrides]
# * one that is completely standalone, excluding paths files and with functions in /lib
#   * possible variant that shares functions? ?why? creates unnecesary version tensions, requires ABI compat, etc - a bit like shared libraries today
#   * if not the above, then core_init_functionsPath
# * one that can run from checkout of git & git submodules

# paths files are composable
# * work simply by combining those defined in shellfire with local choices
# * allow local, git friendly, replacements OR additions

compile_deduceRepositoryFolerPath()
{
	if [ "${TRAVIS_BUILD_DIR+set}" = 'set' ]; then
		readonly compile_repositoryFolderPath="$TRAVIS_BUILD_DIR"
	else
		# We could enforce a standard, like $HOME/Documents/<repo>
		# We could try to resolve $0; we start to copy much of our compatibility logic...
		readonly compile_repositoryFolderPath="$(pwd)"
	fi
	# TRAVIS_COMMIT='ab8186e73e9676d2c547f07b309499ebeed27ec0'
}

_compile_sourceInitFunctionsRecursively()
{
	local parentPath="$1"
	
	local fileOrFolder
	for fileOrFolder in "$1"/*
	do
		if [ -d "$fileOrFolder" ]; then
			_compile_sourceInitFunctionsRecursively "$fileOrFolder"
		elif [ -f "$fileOrFolder" ]; then
			if [ "${fileOrFolder##*.}" = 'init-functions' ]; then
				. "$fileOrFolder"
			fi
		fi
	done
}

compile_sourceInitFunctions()
{
	local libraryFunctionsFolderPath="$core_init_functionsPath"/shellfire
	if [ ! -d "$libraryFunctionsFolderPath" ]; then
		printf '%s\n' "Can not find '$libraryFunctionsFolderPath' - did you run this script from the root of the repository?"
	fi
	_compile_sourceInitFunctionsRecursively "$libraryFunctionsFolderPath"
}

compile_deduceRepositoryFolerPath
core_init_functionsPath="$compile_repositoryFolderPath"/lib
compile_sourceInitFunctions
core_init_main "$@"

# add a shebang line
# copy all .init-functions files into a file
# set the variable  core_init_functionsPath
# if not compiling:-
#  * add a core_init_functionsPath=XXXX definition [perhaps as $(core_init_computeFunctionsPath)]
#  * add a core_init_main "$@"
#  * repeat for sh, dash, bash
# else:-
#  * create special  cores_uses  and  core_functions_register  functions
#  * explicitly call  core_uses core
#  *  source program code
#  * add a core_init_functionsPath=XXXX definition
#  * add a core_init_main "$@"

# we assemble this file, effectively, and so should include a revision_blob or somesuch so we can tell if we're out-of-date
# if it ends .init-functions, it goes in here. Order only matters for the final line  init_main "$@"  but we could generate that
# if we're standing alone, then we need to set core_
# if we're including all functions, then we need to override core_uses

# 0 create empty file somewhere
# 1 set the 
# 2 find all .init-functions, and output to new file
# 3 (optional) output all other functions by overridding core_use

